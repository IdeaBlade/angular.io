include ../_util-fns

:marked
  Libraries are the backbone of the Angular ecosystem.
  They add functionality that would otherwise take a long time to implement from scratch and keep it up to date.
  Everyone benifits from a healthy library ecosystem.

  Traditionally, third party JavaScript libraries have been published in the form of a single JavaScript file.
  Consumers of the library have then included the library, "as is", somewhere on the page using a `script` tag.

  Modern web development has changed this process. 
  Instead of publishing a "one size fits all" bundle, developers want to only include the parts of the library they actually need and in the format they need it in.

  This cookbook shows how to publish a third party library in a way that makes it possible to take advantage of techniques like Ahead of Time Compilation (AoT) and Tree Shaking.

<a id="toc"></a>
:marked
  ## Table of contents

  [Creating a Third Party Library](#third-party-lib)

  [Supporting AoT](#aot)

  [Preparing the library for Tree Shaking](#tree-shaking)

  [Supporting JiT](#jit)

  [Publish](#publish)

  [Integrate with Application](#integrate-with-app)

  [Final Application](#final-app)

  TODO finish this

a#develop-locally
:marked
  ## Setup a local development environment

  Setting up a new library project on your machine is quick and easy with the **QuickStart Library seed**,
  maintained [on github](https://github.com/angular/quickstart-lib "Install the github QuickStart Library repo"). 

:marked
  Make sure you have at least Node 6.9 and NPM 3.0 installed.
  Then ...
  1. Create a project folder (you can call it `quickstart-lib` and rename it later).
  1. [Clone](#clone "Clone it from github") or [download](#download "download it from github") the **QuickStart Library seed** into your project folder.
  1. Install npm packages.
  1. Run `npm start` to launch the sample application.

a#clone
:marked
  ### Clone

  Perform the _clone-to-launch_ steps with these terminal commands.

code-example(language="sh" class="code-shell").
  git clone https://github.com/angular/quickstart-lib.git quickstart-lib
  cd quickstart-lib
  npm install
  npm start

a#download
:marked
  ### Download
  <a href="https://github.com/angular/quickstart-lib" title="Download the QuickStart Library seed repository">Download the QuickStart Library seed</a>
  and unzip it into your project folder. Then perform the remaining steps with these terminal commands.

code-example(language="sh" class="code-shell").
  cd quickstart-lib
  npm install
  npm start

.l-main-section
:marked
  ## Initialize your repository

  If you cloned the package from github, it has a `.git` folder where the official repository's history lives.

  You don't want that git history though - you'll want to make your own. 
  
  Delete this folder and initialize this one as a new repository:

code-example(language="sh" class="code-shell").
  rm -rf .git # use rmdir .git on Windows
  git init

.alert.is-important
  :marked
     Do this only in the beginning to avoid accidentally deleting your own git setup!

a#seed
.l-main-section
:marked
  ## What's in the QuickStart Library seed?

  The **QuickStart Library seed** contains a similar structure to the **Quickstart seed*.
  It's modified to build and test a library instead of an application.
  
  Consequently, there are _many different files_ in the project, 
  most of which you can [learn about later](library-setup-anatomy.html "Library Setup Anatomy").

  Focus on the following TypeScript (`.ts`) files in the **`/src`** folder.

.filetree
  .file src
  .children
    .file demo
    .children
      .file app
      .children
        .file app.component.ts
        .file app.module.ts
    .file lib
    .children
      .file component
      .children
        .file lib.component.ts
      .file service
      .children
        .file lib.service.ts
      .file index.ts
      .file module.ts

+makeTabs(`
    quickstart-lib/ts/src/demo/app/app.component.ts,
    quickstart-lib/ts/src/demo/app/app.module.ts,
    quickstart-lib/ts/src/lib/component/lib.component.ts,
    quickstart-lib/ts/src/lib/service/lib.service.ts,
    quickstart-lib/ts/src/lib/index.ts,
    quickstart-lib/ts/src/lib/module.ts
  `, '', `
    src/demo/app/app.component.ts,
    src/demo/app/app.module.ts,
    src/lib/component/lib.component.ts,
    src/lib/service/lib.service.ts,
    src/lib/index.ts,
    src/lib/module.ts
  `)(format='.')

:marked
  Each file has a distinct purpose and evolves independently as the application grows.

  Files outside `src/` concern building, deploying, and testing your app.
  They include configuration files and external dependencies.

  Files inside `src/lib` "belong" to your library, while `src/demo` contains a demo application
  that loads your library.

  Libraries do not run by themselves, so it's very useful to have this "demo" app while developing 
  to see how your library would look like to consumers.

  When you run `npm start`, the demo application is served.
  
  The following are all in `src/`

style td, th {vertical-align: top}
table(width="100%")
  col(width="20%")
  col(width="80%")
  tr
    th File
    th Purpose
  tr
    td <ngio-ex>demo/app/app.component.ts</ngio-ex>
    td
      :marked
        A demo component that renders the library component and a value from the library service.
  tr
    td <code>demo/app/app.module.ts</code>
    td
      :marked
        A demo `NgModule` that imports the Library `LibModule`.
  tr
    td <ngio-ex>lib/component/app.component.ts</ngio-ex>
    td
      :marked
        A sample library component that renders an `<h2>` tag.
  tr
    td <code>lib/service/lib.service.ts</code>
    td
      :marked
        A sample library service that exports a value.
  tr
    td <code>lib/index.ts</code>
    td
      :marked
        The public API of your library, where you choose what to export to consumers.
  tr
    td <code>lib/module.ts</code>
    td
      :marked
        The library's main `NgModule`, `LibModule`.


.l-main-section
:marked
  ## Entry points

  In order to understand how to build and publish a library, you have to consider _how_ the library is going to be consumed.

  Some users need to add it as a `<script>` tag.
  Others might be using SystemJS instead. 
  Bundlers, like Webpack, are very popular as well. 
  Typescript users need type definitions.
  Rollup users make use of ECMAScript modules for tree-shaking.
  AOT applications need library metadata to compile.

  It's daunting to think of all the ways your library might be used and how to accomodate it, 
  but you don't need to have a "one-size-fits-all" library.

  You can configure `package.json` with more entry points besides [main](https://docs.npmjs.com/files/package.json#main).

  The **Quickstart Library** seed uses a similar set of entry points as Angular itself, 
  aimed at maximizing compatibility:

  - `main` (default): an ES5 [UMD](https://github.com/umdjs/umd) bundle that can be consumed anywhere.
  - `module`: a flat ECMAScript module (FESM) bundle containing ES5 code.
  - `es2015`: a FESM containing ES2015 bundle.
  - `typings`: TypeScript and the AOT compiler will look at this entry for metadata.

code-example(language="json").
  "main": "./dist/angular-quickstart-lib.umd.js",
  "module": "./dist/angular-quickstart-lib.es5.js",
  "es2015": "./dist/angular-quickstart-lib.js",
  "typings": "./dist/angular-quickstart-lib.d.ts",

:marked
  There is also a minified UMD bundle (`angular-quickstart-lib.umd.min.js`) for smaller payloads
  in Plunkers and script tags.

.l-sub-section
  :marked
    A flat ECMAScript module (FESM) is a bundled ECMAScript module where all imports were followed 
    copied onto the same file file.
    It always contains ES module import/export statements but can have different levels of ES code
    inside.

.l-main-section
:marked
  ## The build step

  You can build the library by running `npm run build`. 
  This will generate a `dist/` directory with all the entry points described above.

  All the logic for creating the build can be found in `./build.js`. It consists of roughly 4 steps:

  - Compile with `ngc` for ES5 and ES2015.
  - Inline html and css inside the generated JavaScript files.
  - Copy typings, metatada, html and css.
  - Create each bundle using rollup.

.l-main-section
:marked
  ## Testing

  content

.l-main-section
:marked
  ## Publishing your library

  Every package on NPM has a unique name, and so should yours. 

  -- rename lib

.l-main-section
:marked
  ## title

  content


.l-main-section
:marked
  ## title

  content


.l-main-section
:marked
  ## Appendix: Library Setup Anatomy

  content

=============

.l-main-section
<a id="third-party-lib"></a>
:marked
  ## Creating a Third Party Library

  This cookbook shows how to create a simple Hero-Profile library and publish it with support for AoT compilation and Tree Shaking. 
  
  A version of the library intended for JiT compiled applications will also be included. 

  The code for the Hero-Profile library can be found below.

  To support both AoT and JiT compilation there are two different tsconfig files.
  
  `tsconfig.json` for JiT compilation and `tsconfig-aot.json` for AoT compilation.

+makeTabs(
  `cb-third-party-lib/hero-profile/hero-profile.module.ts,
   cb-third-party-lib/hero-profile/tsconfig-aot.json,
   cb-third-party-lib/ts/tsconfig.json,
   cb-third-party-lib/hero-profile/hero-profile.component.html,
   cb-third-party-lib/hero-profile/hero-profile.component.ts,
   cb-third-party-lib/hero-profile/hero-profile.component.css,
   cb-third-party-lib/hero-profile/hero.ts,
   cb-third-party-lib/hero-profile/package.json`,
  null,
  `hero-profile.module.ts,
   tsconfig-aot.json,
   tsconfig.json,
   hero-profile.component.html,
   hero-profile.component.ts,
   hero-profile.component.css,
   hero.ts,
   package.json`
)(format='.')

.l-main-section
<a id="aot"></a>
:marked
  ## Supporting AoT

  AoT plays an important role in optimizing Angular applications. It's therefore important that third party libraries be published in a format compatible with AoT compilation. Otherwise it will not be possible to include the library in an AoT compiled application.

  Only code written in TypeScript can be AoT compiled.
   
  Before publishing the library must first be compiled using the `ngc` compiler. 
  
  `ngc` extends the `tsc` compiler by adding extensions to support AoT compilation in addition to regular TypeScript compilation.   

:marked
  AoT compilation outputs three files that must be included in order to be compatible with AoT.

  *Transpiled JavaScript*

  As usual the original TypeScript is transpiled to regular JavaScript.

  *Typings files*

  JavaScript has no way of representing typings. In order to preserve the original typings, `ngc` will generate `.d.ts` typings files.
  
  *Meta Data JSON files*

  `ngc` outputs a metadata.json file for every `Component` and `NgModule`. These meta data files represent the information in the original `NgModule` and `Component` decorators.   

  The meta data may reference external templates or css files. These external files must be included with the library.

  ### NgFactories

  `ngc` generates a series of files with an `.ngfactory` suffix as well. These files represent the AoT compiled source, but should not be included with the published library.
  
  Instead the `ngc` compiler in the consuming application will generate `.ngfactory` files based on the JavaScript, Typings and meta data shipped with the library. 

  ### Why not publish TypeScript?

  Why not ship TypeScript source instead? After all the library will be part of another TypeScript compilation step when the library is imported by the consuming application? 
  
  Generally it's discouraged to ship TypeScript with third party libraries. It would require the consumer to replicate the complete build environment of the library. Not only typings, but potentially a specific version of `ngc` as well.

  Publishing plain JavaScript with typings and meta data allows the consuming application to remain agnostic of the library's build environment.

<a id="tree-shaking"></a>
:marked
  ## Preparing the library for Tree Shaking

  In addition to supporting AoT, the library code should also be "Tree Shakable". 
  
  Tree Shakers work best with `ES2015` JavaScript. 
  
  `ES2015` `import` and `export` statements make it easier to statically analyse the code to determine which modules are in use by the application.
  
  By setting the `module` attribute in `tsconfig-aot.json` to `es2015`, the transpiled JavaScript will use `ES2015` modules. 

  The library is made up of several independent files. Bundler frameworks like `Rollup` and `Webpack` need a way to determine the entry point to the module. In this example the entry point is `index.js`, the transpiled version of the index.ts TypeScript barrel.

  The entry point to the module is configured using the `module` attribute in `package.json`. In this case `module` is defined as `"module": "index.js"`.

<a id="jit"></a>
:marked
  ## Supporting JiT

  AoT compiled code is the prefered format for production builds, but due to the long compilation time, it may not be practical to use AoT during development.

  To create a more flexible developer experience, a JiT compatible build of the library should be published as well. The format of the JiT bundle is `umd`, which stands for Universal Module Definition. Shipping the bundle as `umd` ensures compatibility with most common module loading formats.

  The `umd` bundle will ship as a single file containing the JavaScript and inlined versions of any external templates or css. 
  
  The path to the `umd` file identified in package.json as `"main": "bundles/hero-profile.umd.js"` 
  
  In `tsconfig.json` the module for the `umd` bundle is specified as `commonjs`, not `es2015`. This is done to ensure that the bundle can be executed "as is", without further transpilation or bundling.   

  To generate the bundle you will be using a framework called `Rollup`.

  The JiT build assumes the following Rollup and TypeScript configuration.

+makeTabs(
  `cb-third-party-lib/hero-profile/rollup-config.js,
   cb-third-party-lib/ts/tsconfig.json`,
  null,
  `rollup-config.js,
   tsconfig.json`
)(format='.')  
:marked
  Generate the `umd` bundle by running `node_modules/.bin/rollup -c rollup-config.js`.

<a id="publish"></a>
:marked
  ## Publish

:marked
  `Rollup` outputs the `umd` bundle, but prior to bundling, all external templates or css files must be inlined. 
  
  There are a few options for how to do inlining. This cookbook uses an approach borrowed from `Angular Material 2`.

  The idea is to create a node script that will walk the component code and replace `templateUrl` and `styleUrls` references with inlined html and css.

  Additionally the script will remove references to `module.id` since it's no longer needed after templates and css have been inlined.  

  Angular ships with its own set of `umd` bundles. These bundles can be referenced by Rollup when generating the `umd` bundle. 
  
  In this example there is a dependency on `@angular/core`. 
  
  By listing `@angular/core` as a `global` in the configuration, `Rollup` will point to the `@angular/core` umd bundle.

  Normally third party libraries will be published to `npm`. This cookbook simulates publishing by executing all required steps in the `publish.js` script.

  `publish.js` will do the following:

  1) AoT compile the Hero-Profile library by running `node_modules/.bin/ngc -p tsconfig-aot.json`

  2) Inline templates and css using the `inline-resources.js` script

  3) Create an `umd` bundle by running `node_modules/.bin/rollup -c rollup-config.js`

+makeTabs(
  `cb-third-party-lib/hero-profile/publish.js,
  cb-third-party-lib/hero-profile/inline-resources.js`,
  null,
  `publish.js,
  inline-resources.js`
)(format='.')    

.l-main-section
<a id="integrate-with-app"></a>
:marked
  ## Integrate with Application

  The library is now ready to be integrated with either AoT compiled applications or JiT compiled applications. The following sections describes how to configure both.

  For the purposes of this demo the JiT and the AoT versions are loaded using the same index.html page. 

  ### AoT

  AoT compiled applications will integrate the library in the compilation of the application as a whole.

  As in the <a href="/docs/ts/latest/cookbook/aot-compiler.html">AoT compilation Cookbook</a> `ngc` is used in combination with `Rollup` to AoT and Tree Shake the application.

  Run the command `ngc -p tsconfig-aot.json && rollup -c rollup-config.js` to execute the combined steps of AoT compilation and Tree Shaking.

  `tsconfig-aot.json` and `rollup-config.js` contain the necessary configuration.

+makeTabs(
  `cb-third-party-lib/ts/rollup-config.js,
   cb-third-party-lib/ts/tsconfig-aot.json`,
  null,
  `rollup-config.js,
   tsconfig-aot.json`
)(format='.')

:marked
  Inside `rollup-config` there is a `nodeResolve` section. This is where the `module` setting from `package.json` comes into play.

  `nodeResolve` will look for either `module` or `jsnext` in `package.json` to determine how to bundle external libraries.

+makeExample('cb-third-party-lib/ts/rollup-config.js', 'nodeResolve', 'rollup-config.js')(format=".")

:marked
  The combined output of `ngc` and `Rollup` is a single `build.js` JavaScript file. 
  
  `build.js` contains the entire application including all Angular dependencies and the third party Hero-Profile library.

  To run the application in AoT mode, include `build.js` as a script tag and the `my-aot-app` root level component tag in `index.html`

  ### JiT

  JiT applications load the `umd` bundle using `SystemJS`. This requires a minor tweak to `systemjs.config.js` to register the `umd` bundle with `SystemJS`.

  Simply add `'hero-profile': 'npm:hero-profile/bundles/hero-profile.umd.js'` to the map section of `systemjs.config.js`. 

.l-main-section
<a id="final-app"></a>
:marked
   ## Final Application 

   If you have cloned the `Angular.io` repo, all the steps described in this cookbook can be executed by running the following command:

   `gulp add-example-boilerplate && npm run build:aot:jit && npm run lite`

   After loading both the JiT and AoT versions of the library the final application looks like this:
figure.image-display
   img(src="/resources/images/cookbooks/third-party-lib/third-party-lib.png" alt="Third-Party-Library")
