include ../../../../_includes/_util-fns


.l-main-section

  :markdown
   Dependency injection has always been one of Angular's biggest features. It allows us to inject dependencies in different components across our applications, without needing to know, how those dependencies are created, or what dependencies they need themselves. In this chapter we're going to explore the dependency injection system that comes with the Angular framework.

   ## Understanding Dependency Injection

   Before we take a look at what Angular's implementation of dependency injection looks like, we first need to understand what it is and why we want this feature at all. Dependency Injection can be interpreted in two different ways. One way is to treat it as a **design pattern**, the other one is to treat it as a framework. Whereas the former explains the pattern that DI is all about, the latter can be a system that helps us out maintaining and assembling dependencies.

   Let's start by taking a look at the following code and analysing the problems it introduces.

   **[INSERT CODE HERE]**

   Nothing special here. We have a class `Car` that has a constructor in which we set up everything we need in order to construct a car object once needed. What's the problem with this code? Well, as you can see, the constructor not only assigns needed dependencies to internal properties, it also knows how those object are created. For example the engine object is created using the `Engine` constructor, `Tires` seems to be a singleton interface and the doors are requested via a global object.

   This leads to code that is hard to maintain and even harder to test. Just imagine we'd like to test this class. How would we replace `Engine` with a `MockEngine` dependency in that code? When writing tests, we want to test different scenarios that our code is used in, hence each scenario needs it's own configuration. If we want to write testable code, we need to write reusable code that works in any environment as long as all dependencies are satisfied. Which brings us to the conclusion that **testable code is reusable code** and vise versa.

   How can we write this code better and make it more testable? Turns out this is super easy and you probably already know what to do. We change our code to this:

   **[INSERT CODE HERE]**

   All we did is we moved the dependency creation out of the constructor and extended the constructor function to expect all needed dependencies. There are no concrete implementations anymore in this code, we literally moved the responsibility of creating those dependencies to a higher level. If we now want to create a car object, all we have to do is to pass all needed dependencies to the constructor:

   **[INSERT CODE HERE]**

   How cool is that? The dependencies are now decoupled from our class, which allows us to pass in mocked dependencies in case we're writing tests:

   **[INSERT CODE HERE]**

   Believe or not, but **we just learned what Dependency Injection is**. It's really just a pattern that describes that needed dependencies of an entity should either be passed to it's constructor, or to dedicated setter methods of that entity. 

   Okay cool, now we know what DI is and how to use it, but when comes a "DI as a framework" into play? As mentioned before, we literally moved the responsibility of dependency creation to a higher level. This is exactly what our new problem is. Who takes care of assembling all those dependencies for us? Well... It's us.

   **[INSERT CODE HERE]**

   We now need to maintain a `main` function. Doing that manually can be quite hairy, especially when the application gets bigger and bigger. Wouldn't it be nice if we could do something like this?

   **[INSERT CODE HERE]**

   In this code, we don't have to know what dependencies are needed to create an object of type `Car`. We just create an injector that figures out how to do that. This is what **Dependency Injection as a framework** is all about. No `main` method required where we have to assemble all of our dependencies ourselves. We have an injector that takes care of that.
   
   Now that we have a proper understanding of what Dependency Injection is, let's take a look at how that's implemented in Angular.

   ## Dependency Injection in Angular 2

   Angular 2 introduces a new Dependency Injection system that is much more flexible than the one implemented in AngularJS. In order to understand how DI in Angular works, we first need to take a look at the basic concepts behind that new system. The following figure illustrates it's components and their relation.

   **[INSERT FIGURE HERE]**

   
   DI in Angular basically consists of three things:

   - **Injector** - The injector object that exposes APIs to us to create instances of dependencies.
   - **Binding** - A binding is like a recipe that tells the injector **how** to create an instance of a depedency. A binding needs a token that maps to a factory function that creates an object.
   - **Dependency** - A binding might need it's own dependencies in order to work.

   Let's take these concepts and see how they work in code. The following examples will use For simplicity-sake, we stick with our `Car` class and it's dependencies. If we'd

   .callout.is-helpful
     header Note
     p.
       While you've used <code>template:</code> to specify an inline view, for larger templates you'd want to move them to a separate file and load them with <code>templateUrl:</code> instead.
